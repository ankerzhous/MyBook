## 一、创建方式

+ 继承Thread类

  ```java
  public class Thread1 extends Thread{
      public void run(){
          System.out.println("执行了...");
      }
   public static void main(String[] args) {
       new Thread1().start(); 
   } 
  }
  ```

+ 实现Runnable接口

  ```java
  public static void main(String[] args) {
       new Thread(new Runnable(){
           public void run(){
          System.out.println("执行了...");
      	}
       }).start(); 
   } 
  }
  ```

+ 实现callable接口

  

## 二、线程的状态

**五种状态：**

![](C:\Users\Sander\Desktop\java笔记\imgs\线程状态.png)



**七种状态：**

![img](https://img-blog.csdn.net/20150309140927553)

阻塞状态：

​	1）等待阻塞：执行wait()时，进程进入等待池，并释放对象锁

​    2）同步阻塞：进程拿不到对象锁

​	3）其他阻塞：进程调用sleep（），join（），或者处理IO时进入阻塞状态，处理完成会进入就绪态

## 三、线程的方法

#### 1.Thread的静态类方法

##### 	1）sleep()

​		当前正在执行的线程休眠。

##### 	2）currentThread()

##### 	3）yield()	

​		调用yield方法会让当前线程交出CPU权限，让CPU去执行其他的线程。

​		进入就绪态

#### 2.Thread的对象方法

##### 	1)   join

等待当前线程结束。

```java
public class Thread4 extends Thread{
    public Thread4(String name) {
        super(name);
    }
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(getName() + "  " + i);
        }
    }
    public static void main(String[] args) throws InterruptedException {
        // 启动子进程
        for (int i = 0; i < 10; i++) {
            if (i == 5) {
                Thread4 th = new Thread4("joined thread");
                th.start();
                th.join();
            }
            System.out.println(Thread.currentThread().getName() + "  " + i);
        }

    }
}

```

可以看出在子线程在调用join后立刻得到了cpu使用权，主线程等待子线程运行结束。

```
main  0
main  1
main  2
main  3
main  4
joined thread  0
joined thread  1
joined thread  2
joined thread  3
joined thread  4
main  5
main  6
main  7
main  8
main  9

若不使用join()
main  0
main  1
main  2
main  3
main  4
main  5
main  6
main  7
main  8
main  9
joined thread  0
joined thread  1
joined thread  2
joined thread  3
joined thread  4
```

##### 	2) setDaemon和isDaemon

用来设置线程是否成为守护线程和判断线程是否是守护线程。

守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。

##### 	3) getName和setName

##### 	4) getPriority和setPriority

##### 	5) getId()

##### 	6) isActive()

##### 	7) start()和run()

#### 	3.Object中的相关方法

5.  wait(): obj对象的方法,必须和synchronized一起使用。先释放锁，再休眠本线程。

6. notify() ,notifyAll(): 唤醒被wait()的线程，但是并不直接拿到锁。


### 方法区分

1.wait和sleep的区别？

**共同点**：

+ 都可以在程序的调用处阻塞指定的毫秒数，并返回。
+ **wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。**

**不同点：**

+ Thread类的静态方法：sleep(),yield()等，调用时使用Thread.sleep()
    Object的方法：wait()和notify()等
+ 都是休眠，但方式略微不同，wait会把线程加入等待队列中。
+ **wait会释放锁，sleep不会。**
+ wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

### synchronized

1. synchronized(*.class) 或者 public static synchronized  Method(){} 

 给类上锁，使该类的所有对象互斥访问  （一个线程一个对象）

```java
public class Account {
    private static int num;
    public void count(){
      synchronized (Account.class){
        num++;
        System.out.println(Thread.currentThread().getName()+" 您是第"+num+"位访客");
      }
    }
}
```

```java
 public static void main(String[] args) {
        for (int i = 0; i <1000 ; i++) {
            new Thread(()->{
               new account.count();
            }).start();
        }
 }
```

2. synchronized(this)  或者public synchronized Method(){}

给对象上锁，使得该对象的所有线程可以互斥访问 （多个线程使用一个对象）

```java
public class Account {
    private static int num;
    public void count(){
      synchronized (this){
        num++;
        System.out.println(Thread.currentThread().getName()+" 您是第"+num+"位访客");
      }
    }
}
```

```java
 public static void main(String[] args) {
        Account account = new Account();
        for (int i = 0; i <1000 ; i++) {
            new Thread(()->{
                account.count();//每个线程都是在用同一个对象的同一方法
            }).start();
        }
  }
```

## 四、并发编程

juc包下的一些便于并发编程的类

### 1.ReentrantLock

1. ReentrantLock（lock）和synchronzied的区别：

   + synchronzied是通过jvm实现的锁机制，ReentrantLock是jdk提供锁机制

   + synchronzied是关键字，ReentrantLock是类

   + synchronzied自动释放，ReentrantLock要手动解锁

   + synchronized 拿不到锁就会⼀直等待，Lock 不⼀定会⼀直等待。

   + synchronized 无法判断是否获取到了锁，Lock 可以判断是否拿到了锁。

   + synchronized 是非公平锁，Lock 可以设置是否为公平锁。

     公平锁：很公平，排队，当锁没有被占⽤时，当前线程需要判断队列中是否有其他等待线程。

     非公平锁：不公平，插队，当锁没有被占⽤时，当前线程可以直接占⽤，⽽不需要判断当前队列中是否

     有等待线程。

​	Lock接口的一个实现类 常用方法：

| 方法名                                    | 作用                                  |
| ----------------------------------------- | ------------------------------------- |
| void lock()                               | 上锁                                  |
| void unlock()                             | 解锁                                  |
| boolean tryLock(long time, TimeUnit unit) | 在指定时间内尝试上锁，失败则返回false |
| Condition newCondition();                 | lock可以创建condition对象             |

### 2.**ConcurrentModifificationException**

并发修改异常：多线程并发，同时读写容器时会出现的异常

```java
public class Test {
    public static void main(String[] args) {
        List<Integer> list = new CopyOnWriteArrayList<>();
        for (int i = 0; i <10 ; i++) {
            new Thread(()->{
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                list.add(1);
                System.out.println(list);
            }).start();
        }
    }
}
```

如何解决？

1. 使用安全的容器 Vector hashTable 

2. 使用工具类Collections ：Collections.synchronizedList

3. JUC：CopyOnRightArraylist等集合

   ```java
   List<Integer> list = new CopyOnWriteArrayList<>();
   Set<String> set = new CopyOnWriteArraySet<>();
   Map<String,String> map = new ConcurrentHashMap<>();
   ```

### 3.JUC工具类

#### 1.减法计数器

new CountDownLatch(100) 

countDown()：计数器减一

 await(): 等待计数器清零，另一个线程也处于等待，无法开始执行

 三个方法必须配合使用，可以确保一个进程优先执行，当计数器清零，另一个线程执行。

代码解释：

1. 搞了一个减法计数器，和一个线程，线程内部执行一百次countDown

2. 从执行结果得出另一个线程根本没启动，所以await()是在等待计数器清零，否则不执行 

```java
public class Test {
    public static void main(String[] args) {
      CountDownLatch countDownLatch = new CountDownLatch(100);
      new Thread(()->{
          for (int i = 0; i <100 ; i++) {
              System.out.println("+++++++++++++Thread");
              countDownLatch.countDown();
          }
      }).start();
        try {
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (int i = 0; i <100 ; i++) {
              System.out.println("++++++++++++++main");
         }
    }
}
```

#### 2.加法计数器

CyclicBarrier 

用法：当达到临界值时去执行某个任务，设置cyclicBarrier.await(）尝试唤醒该任务

构造方法：

```java
 CyclicBarrier cyclicBarrier = new CyclicBarrier(10,()->{
            System.out.println("放行");
       });
```

代码解释：

1.设置了一个任务-放行，计数器满时执行。

2.搞了100个线程，每个线程内部都有cyclicBarrier.await()，每个线程都会尝试去唤醒，但只有计数器满才会唤醒成功并且执行放行。

```java
public class Test2 {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(10,()->{
            System.out.println("放行");
        });
        for (int i = 0; i < 100 ; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"=================");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

#### 3.读写锁

一种粒度更小的锁，可以给读和给写操作加锁，能保证同时只有一个线程在写，多个线程在读。

```java
public class Test3 {
    public static void main(String[] args) {
        Cathe cathe  = new Cathe();
        new Thread(()->{
            for (int i = 0; i <5 ; i++) {
                cathe.read(i,String.valueOf(i));
            }
        }).start();

        new Thread(()->{
            for (int i = 0; i <5 ; i++) {
                cathe.write(i);
            }
        }).start();

    }
}

class Cathe{
    HashMap<Integer, String> map = new HashMap<>();
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    public void read(Integer key, String value){
        readWriteLock.readLock().lock();
        System.out.println(key+"开始写入");
        map.put(key, value);
        System.out.println(key+"写⼊完毕");
        readWriteLock.readLock().unlock();

    }
    public void write(Integer key){
        readWriteLock.readLock().lock();
        System.out.println(key+"开始读取");
        map.get(key);
        System.out.println(key+"读取完毕");
        readWriteLock.readLock().unlock();
    }

}
```

### 4.线程池

![image-20200414124126911](C:\Users\Sander\AppData\Roaming\Typora\typora-user-images\image-20200414124126911.png)

线程池是一个控制一系列线程的容器

+ 初始化时创建一定数量的线程对象
+ 如果线程池没有空闲的线程对象，则新来的任务进入等待队列
+ 等待队列也满了，可以再申请线程对象直到达到线程池最大值，此时再有任务进来则直接拒绝

池化技术 池化思想

优势：

1. 提高相应速度
2. 提高线程利用率
3. 可控制最大并发数
4. 便于统一管理

设计思想：

1. 核心池的大小
2. 线程池最大容量
3. 等待队列
4. 拒绝策略

#### 1.创建线程池的方式

 Executors.newSingleThreadExecutor()创建 

executorService.execute（Runnable）传入任务

executorService.shutdown();结束任务

```java
public class Test {
    public static void main(String[] args) {
        //单例线程池
        // ExecutorService executorService = Executors.newSingleThreadExecutor();
        //数量固定的线程池
        //ExecutorService executorService = Executors.newFixedThreadPool(5);
        //缓存线程池，线程池的线程实例数量随机，由电脑配置决定
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i <100 ; i++) {
            final int temp = i;
            executorService.execute(()->{
                System.out.println(Thread.currentThread().getName()+":"+temp);
            });
        }
        executorService.shutdown();
    }
}

```

#### 2.ThreadPoolExecutor

以上三种方式底层都是通过ThreadPoolExecutor实现的

该对象的参数：

1. corePoolSize:核心池大小，初始化线程数量

2. maximumPoolSize：线程池最大线程数

3. keepAliveTime:线程对象存活时间(在没有任务可执行的情况下)，必须是线程池中线程数大于核心池时

4. TimeUnit : 线程对象存活时间的单位

5. BlockingQueue：等待队列，存储等待执行的任务

   4个线程阻塞队列：

   + ArrayBlockingQueue 基于数组的等待队列，创建时必须指定大小。
   + LinkedBlockingQueue 基于链表的等待队列，创建时可以不指定大小，默认值是Integer.MAX_VALUE
   + SynchronousQueue：它不会保持提交的任务，而是直接新建⼀个线程来执行新来的任务。
   + PriorityBlockingQueue：具有优先级的阻塞队列。

6. ThreaTdFactory: 线程工厂，用来创建线程对象

7. RejectedExecutionHandler：拒绝策略
   + AbortPolicy：直接抛出异常
   + DiscardPolicy：放弃任务，不抛出异常
   + DiscardOldestPolicy：尝试与等待队列中最前⾯的任务去争夺，不抛出异常
   + CallerRunsPolicy：谁调⽤谁处理

```java
import java.util.concurrent.*;
public class Test {
    public static void main(String[] args) {
        ExecutorService executorService = null;
        try {
            executorService = new ThreadPoolExecutor(
                    2,
                    3,
                    1L,
                    TimeUnit.SECONDS,
                    new ArrayBlockingQueue<>(2),
                    Executors.defaultThreadFactory(),
                    new ThreadPoolExecutor.AbortPolicy()
            );
            for (int i = 0; i <14 ; i++) {
                executorService.execute(()->{
                    System.out.println(Thread.currentThread().getName()+"办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            executorService.shutdown();
        }

    }
}
```

#### 3.ForkJoin

并发框架 ，将一个大任务拆分成多个小任务，并发执行并汇总。

核心是两个类：

+ ForkJoinTask
+ ForkJoinPool

如何使用:

1. ForkJoinTask 是一个抽象类，无法直接实例化，必须自定义一个类继承ForkJoinTask的子类RecursiveTask，重写computer（）方法，用fork() and join()拆分和合并
2. 把该任务加入到ForkJoinPool实例中。

自定义任务 ：

```java
public class ForkJoinDemo extends RecursiveTask<Long> {
    private Long start;
    private Long end;
    private Long temp = 10_0000L;

    public ForkJoinDemo(Long start, Long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if((end-start)<temp){
            Long sum = 0L;
            for (Long i = start; i <=end ; i++) {
                sum+=i;
            }
            return sum;
        }else {
            Long avg = (start+end)/2;
            ForkJoinDemo task1 = new ForkJoinDemo(start,avg);
            task1.fork();
            ForkJoinDemo task2 = new ForkJoinDemo(avg, end);
            task2.fork();
            return task1.join()+task2.join();
        }
    }
}
```

Test.java

```java
public class Test {
    public static void main(String[] args) {
        Long startTime = System.currentTimeMillis();
        ForkJoinPool forkJoinPool  = new ForkJoinPool();
        ForkJoinTask<Long> task = new ForkJoinDemo(0L,10_0000_0000L);
        forkJoinPool.execute(task);
        Long sum = 0L;
        try {
            sum = task.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        Long endTime = System.currentTimeMillis();
        System.out.println(sum+"，供耗时"+(endTime-startTime));
    }
}
```

### 5.volatile

作用：主内存对线程可见

一个线程执行完任务之后会把变量存回主存，并从主存中读取当前变量最新的值，但当任务为空时则不会读取。

## 五、经典问题

### 1、三个打印线程

打印机ABC交替执行，打印ABC十次

三个资源 ，三个线程。每个线程使用时占用两个资源就可保证交替执行

```java
package thread.thread10;

import java.io.IOException;


public class ThreadPrinter implements Runnable {
    private String name;
    private Object prev;
    private Object self;

    public ThreadPrinter(String name, Object prev, Object self) {
        this.name = name;
        this.prev = prev;
        this.self = self;
    }

    @Override
    public void run() {
        int count = 10;
        while(count>0) {
            synchronized (prev) {
                synchronized (self) {
                    System.out.print(name);
                    count--;
                    self.notify();
                }
                try {
                    prev.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        //创造三个资源，每个线程必须拿到两个才能运转
        Object a = new Object() ;
        Object b = new Object() ;
        Object c = new Object() ;
        ThreadPrinter threadA = new ThreadPrinter("A",c,a);
        ThreadPrinter threadB = new ThreadPrinter("B",a,b);
        ThreadPrinter threadC = new ThreadPrinter("C",b,c);
        new Thread(threadA).start();
        Thread.sleep(111);  //确保按顺序A、B、C执行
        new Thread(threadB).start();
        Thread.sleep(111);
        new Thread(threadC).start();
        Thread.sleep(111);
    }
}
```

### 2、生产者消费者

要求：

一个容器，有生产者，有消费者，每个生产者和消费者内部不断的生产和消费产品。

保证容器为空时不能再消费，容器满时不能再生产，生产和消费不能同时进行。

思路：

1. 用synchronized 修饰生产过程和消费过程，给当前线程拿到锁 ，保证互斥生产消费。
2. 在满和空时让进程休眠的同时释放锁，避免死锁。
3. 完成一个生产或消费后试图唤醒所有线程。

```java
package thread.thread11_producer;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static thread.thread11_producer.Test.*;

public class Test {

    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.increase();
            }
        }).start();
        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.decrease();
            }
        }).start();
    }

}

class Data{
    private static  int count = 0;
    private Object lock = (Object)"lock";
    private final int Full = 10;
    public void increase()  {
       synchronized(lock){
        while(count==Full) {
            try {
                lock.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            TimeUnit.MILLISECONDS.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count++;
        System.out.println(Thread.currentThread().getName()+"生产了一个产品，共"+count+"个");
        lock.notifyAll();
       }
    }
    public void decrease()  {
        synchronized(lock){
        while(count==0) {
            try {
               lock.wain();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count--;
        System.out.println(Thread.currentThread().getName()+"消费了一个产品，还剩"+count+"个");
       	lock.notify();
        }
        }
}
```

重入锁实现

```java
package thread.thread11_producer;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static thread.thread11_producer.Test.*;

public class Test {

    public static void main(String[] args) {
        Data data = new Data();
        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.increase();
            }
        }).start();
        new Thread(()->{
            for (int i = 0; i <10 ; i++) {
                data.decrease();
            }
        }).start();
    }

}

class Data{
    private static  int count = 0;
    private Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    private final int Full = 10;
    public void increase()  {
        lock.lock();
        while(count==Full) {
            try {
                condition.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            TimeUnit.MILLISECONDS.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count++;
        System.out.println(Thread.currentThread().getName()+"生产了一个产品，共"+count+"个");
        condition.signalAll();
        lock.unlock();
    }
    public void decrease()  {
        lock.lock();
        while(count==0) {
            try {
                condition.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        count--;
        System.out.println(Thread.currentThread().getName()+"消费了一个产品，还剩"+count+"个");
        condition.signalAll();
        lock.unlock();
    }
}
```

### 3、哲学家进餐

### 4、多线程并发买票

### 5、线程同步的单例





 