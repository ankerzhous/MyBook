#  题库

## **一、Java 基础**

#### 0.全局变量，局部变量？

全局变量：

+ 静态变量：
+ 成员变量（实例属性）：

局部变量：

+ 方法里得哪个

#### 1.JDK 和 JRE 有什么区别？

​		JDK:  开发工具包  (面向的是开发者，编译运行调试)

​		JRE:  java运行环境（面向用户，运行java程序的环境，不需要类库和调试）

​		JDK > JRE  > JVM

#### 2.== 和 equals 的区别是什么？

​		==： 基本数据类型，比较值是否相等。引用数据类型比较的是引用地址是否相同。（基本数据类型保存在栈          引用数据类型也保存在栈中，对象保存在堆中）

​		equals：定义在Object中是 ==，如果没有重写就是比较内存地址是否相同，如果重写，如String就是比较内容是否相同。

#### 3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？

​		hashCode（）:  返回一个哈希码，这个哈希码能够确定对象在内存中的位置。

​		hashCode()和equals()都是可以重写的，返回的值完全在于自己定义。

关于hashCode和equal是方法是有一些 常规协定 ：

1、两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。

2、两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提搞哈希表性能。

3、重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。

#### 4.final 在 java 中有什么作用 

1. 修饰类的时候，不能被继承
2. final修饰方法，锁定方法，防止任何继承类修改这个方法
3. 修饰变量，如果是基本数据类型，那就不能再改变，如果是引用类型，那就不能指向其他引用		

#### 5.java 中的 Math.round(-1.5) 等于多少？

​		-1

- round() ：返回四舍五入，负 .5 小数返回较大整数，如 -1.5 返回 -1。
- ceil() ：返回小数所在两整数间的较大值，如 -1.5 返回 -1。
- tail() ：返回小数所在两整数间的较小值，如 -1.5 返回 -2。

#### 8.String str="i"与 String str=new String(“i”)一样吗？

​		不一样 前者创建的对象在常量池，后者在堆中

​		常量池存放常量，如基本类型的包装类（Integer，Short）和String

#### 10.String 类的常用方法都有那些？

​      length() , isEmpt(), equals()

  1.  和查找相关的方法

      int charAt() 返回指定下标的字符

      startWith(String value)

      endeWith(String value)

      indexOf(String str)               返回str在字符串中的下标

      indexOf(String str, int fromindex)  返回str从指定位置的下标

2. 修改

   追加                public concat(Stirng str)

   截取				public String[] split(String regex)

   替换：			

   + 换大写		public String toLowerCase(String str)
   + 换小写        public String toUpperCase(String str)	
   + 替换元素    public String replaceAll(String s, String n)
   + split             用元素分割

3. 转换

   + 转换为字符数组 byte[] getBytes() 
   + 转换为字节数组 char[] toCharArray()

#### 11.抽象类必须要有抽象方法吗？

​	 抽象类和抽象方法描述一种类应该有的特征和方法，具体由子类实现。

​	 可以没有抽象方法 

#### 12.普通类和抽象类有哪些区别？

1. 抽象类不能实例化，普通类可以

2. 如果一个类继承于抽象类，则该子类必须实现父类的抽象方法。

#### 13.抽象类能使用 final 修饰吗？

​	不能，抽象类就是让其他类继承的，如果定义为final该类就不能被继承，就会产生矛盾

#### 14.接口和抽象类有什么区别？

​	抽象类用abstract修饰，接口用interferce修饰

​	一个类只能继承一个抽象类，但是可以实现多个接口，

#### 15.java 中 IO 流分为几种？

​	字节流，字符流      

​	节点流，处理流

​	输入流，输出流	

#### 16.BIO、NIO、AIO 有什么区别？

IO操作分为两个步骤：发起IO请求 和 实际IO操作。

##### 同步异步 和阻塞非阻塞的区别在于一个主动和被动：

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）。
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者。

​	BIO：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。

​	NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

​	AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由操作系统先完成IO操作后再通知服务器应用来启动线程进行处理。

#### 17.File的常用方法都有哪些？

```java
File file = new File("dada");
file.idDirectory();
file.isFile();
file.exist();
file.delete();
file.list();
file.listFiles();
```

## **二、容器**

#### 18.java 容器都有哪些？

collection：

1. set:
   + HashSet
   + TreeSet
   + LinkedHashSet
2. list
   + ArrayList
   + LinkedList
   + Vector
3. queue
   + priorQueue

map

1. HashMap
2. HashTable
3. LinkedHashMap

#### 19.Collection 和 Collections 有什么区别？

​		Collections.sort()

#### 20.List、Set、Map 之间的区别是什么？

​		

#### 21.HashMap 和 Hashtable 有什么区别？

#### 22.如何决定使用 HashMap 还是 TreeMap？

​	如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）

#### 23.说一下 HashMap 的实现原理？

- HashMap 基于 Hash 算法实现，通过 put(key,value) 存储，get(key) 来获取 value
- 当传入 key 时，HashMap 会根据 key，调用 hash(Object key) 方法，计算出 hash 值，根据 hash 值将 value 保存在 Node 对象里，Node 对象保存在数组里
- 当计算出的 hash 值相同时，称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value
- 当 hash 冲突的个数：小于等于 8 使用链表；大于 8 时，使用红黑树解决链表查询慢的问题

#### 24.说一下 HashSet 的实现原理？

​	底层是HashMap

#### 25.ArrayList 和 LinkedList 的区别是什么？

#### 26.如何实现数组和 List 之间的转换？

```java
List<String> list1 = Arrays.asList(arr);//数组转List 
String[] a = list1.toArray[];//List转数组
```

#### 27.ArrayList 和 Vector 的区别是什么？

#### 28.Array 和 ArrayList 有何区别？

​	Array是数组，大小固定，类型固定

#### 29.在 Queue 中 poll()和 remove()有什么区别？

​		1、offer()和add()的区别

​		add()和offer()都是向队列中添加一个元素。但是如果想在一个满的队列中加入一个新元素，调用 add() 方法就会抛出一个 unchecked 异常，而调用 offer() 方法会返回 false。可以据此在程序中进行有效的判断！

​		2、peek()和element()的区别

​		peek()和element()都将在**不移除**的情况下返回队头，但是peek()方法在队列为空时返回null，调用element()方法会抛出NoSuchElementException异常。

​		3、poll()和remove()的区别

​		poll()和remove()都将**移除**并且返回对头，但是在poll()在队列为空时返回null，而remove()会抛出NoSuchElementException异常。

#### 30.哪些集合类是线程安全的？

​	Vector, HashTable , ConcurrentHashMap, Stack：栈，也是线程安全的，继承于Vector。

#### 31.迭代器 Iterator 是什么？

​		Iterator 是可以遍历集合的对象

#### 32.Iterator 怎么使用？有什么特点？

```java
 public static void testIteratorNext() {
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String str = iterator.next();
            System.out.println(str);
        }
    }
```



#### 33.Iterator 和 ListIterator 有什么区别？

1. 使用范围不同，Iterator可以应用于所有的集合，Set、List和Map和这些集合的子类型。而ListIterator只能用于List及其子类型。
2. ListIterator有add方法，可以向List中添加对象，而Iterator不能。
3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator不可以。
4. ListIterator可以定位当前索引的位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。
5. 都可实现删除操作，但是ListIterator可以实现对象的修改，set()方法可以实现。Iterator仅能遍历，不能修改。

#### 34.怎么确保一个集合不能被修改？

​	Collections包也提供了对list和set集合的方法。
​	Collections.unmodifiableList(List)
​	Collections.unmodifiableSet(Set)

## **三、多线程**

#### 35.并行和并发有什么区别？

#### 36.线程和进程的区别？

​	进程是资源分配最小单位，线程是程序执行的最小单位。

​	进程之间资源独立，线程之间共享进程的资源

​	线程是处理机调度的基本单位

#### 37.守护线程是什么？

#### 38.创建线程有哪几种方式？

 	1. 继承Thread类
      	2. 新建Thread类，实现Runnable接口

#### 39.说一下 runnable 和 callable 有什么区别？

#### 40.线程有哪些状态？

​	5种状态 

​	新建，运行态，就绪态，阻塞态，死亡

​	7种状态

外加等待队列

#### 41.sleep() 和 wait() 有什么区别？

​	sleep()来自Thread类的静态方法，wait()来自Object类，所以sleep不涉及线程之间的通信，不会放弃锁，**wait()**是Object的方法，用于线程间的通信，调用时会**放弃对象锁**，进入**等待**队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才进入对象锁定池准备获得对象锁进入运行状态。

#### 42.notify()和 notifyAll()有什么区别？

- 锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
- 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中

> Reference：[java中的锁池和等待池](https://link.zhihu.com/?target=http%3A//blog.csdn.net/emailed/article/details/4689220)

然后再来说notify和notifyAll的区别

- 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的**等待池**中，等待池中的线程**不会去竞争该对象的锁**。
- 当有线程调用了对象的 **notifyAll**()方法（唤醒所有 wait 线程）或 **notify**()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争
- 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它**还会留在锁池中**，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

#### 43.线程的 run()和 start()有什么区别？

#### 44.创建线程池有哪几种方式？

#### 45.线程池都有哪些状态？

#### 46.线程池中 submit()和 execute()方法有什么区别？

#### 47.在 java 程序中怎么保证多线程的运行安全？

#### 48.多线程锁的升级原理是什么？

#### 49.什么是死锁？

​	线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。

#### 50.怎么防止死锁？

#### 51.ThreadLocal 是什么？有哪些使用场景？

#### 52.说一下 synchronized 底层实现原理？

#### 53.synchronized 和 volatile 的区别是什么？

​	主内存对线程可见

#### 54.synchronized 和 Lock 有什么区别？

1. 前者jvm层面的，后者jdk层面
2. 前者不需要手动释放，后者需要, lock() unlock()去释放
3. 前者不可中断，后者可以中断
4. 后者可以精确唤醒，前者不可以

#### 55.synchronized 和 ReentrantLock 区别是什么？

#### 56.说一下 atomic 的原理？

#### T1.当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？ 

答：

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。



## **四、反射**

57.什么是反射？

58.什么是 java 序列化？什么情况下需要序列化？

序列化：将 Java 对象转换成字节流的过程。

当 Java 对象需要在网络上传输 或者 持久化存储到文件中时，就需要对 Java 对象进行序列化处理。

59.动态代理是什么？有哪些应用？

60.怎么实现动态代理？

## **五、对象拷贝**

61.为什么要使用克隆？

62.如何实现对象克隆？

63.深拷贝和浅拷贝区别是什么？

## **六、Java Web**

64.jsp 和 servlet 有什么区别？

65.jsp 有哪些内置对象？作用分别是什么？

​	Request,Response,session,application,pageContext,Config

66.说一下 jsp 的 4 种作用域？

  **page session application request**

#### **68.*说一下 session 的工作原理？**

​	客户端完成登录以后，服务器会创建对应的session，session创建完后会把session的id发送给客户端，客户端再存储到浏览器中。这样客户端每次请求时都能带上sessionid，服务器拿到sessionid就能在内存中找到session了。

69.如果客户端禁止 cookie ， session 还能用吗？

​	**一般默认情况下**，在会话中，服务器存储 session 的 sessionid 是通过 cookie 存到浏览器里。

​	如果浏览器禁用了 cookie，浏览器请求服务器无法携带 sessionid，服务器无法识别请求中的用户身份，**session失效**。

​	但是可以**通过其他方法**在禁用 cookie 的情况下，**可以继续使用session**。

1. ​     通过url重写，把 sessionid 作为参数追加的原 url 中，后续的浏览器与服务器交互中携带 sessionid 参数。
2. 服务器的返回数据中包含 sessionid，浏览器发送请求时，携带 sessionid 参数。
3. 通过 Http 协议其他 header 字段，服务器每次返回时设置该 header 字段信息，浏览器中 js 读取该 header 字段，请求服务器时，js设置携带该 header 字段。

70.spring mvc 和 struts 的区别是什么？

71.如何避免 sql 注入？

72.什么是 XSS 攻击，如何避免？

73.什么是 CSRF 攻击，如何避免？

## **七、异常**

74.throw 和 throws 的区别？

75.final、finally、finalize 有什么区别？

76.try-catch-finally 中哪个部分可以省略？

77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

78.常见的异常类有哪些？

## **八、网络**

79.http 响应码 301 和 302 代表的是什么？有什么区别？https?

80.forward 和 redirect 的区别？

81.简述 tcp 和 udp的区别？

82.tcp 为什么要三次握手，两次不行吗？为什么？

83.说一下 tcp 粘包是怎么产生的？

84.OSI 的七层模型都有哪些？

85.get 和 post 请求有哪些区别？

86.如何实现跨域？

87.说一下 JSONP 实现原理？

## **九、设计模式**

88.说一下你熟悉的设计模式？

设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。

①创建型模式（ Creational Patterns ）：

- 工厂模式（Factory pattern）
- 抽象工厂模式（Abstract Factory Pattern）
- 单例模式（Singleton Patern）
- 创建者模式（Builder Pattern）
- 原型模式（Prototype Pattern）

  ②结构型模式（ Structural Patterns ）：

- 适配器模式（Adapter Pattern）
- 桥接模式（Bridge Pattern）
- 过滤器模式（Filter Pattern）
- 组合模式（Composition Pattern）
- 装饰器模式（Decorator Pattern）
- 外观模式（Facade Pattern）
- 代理模式（Proxy Pattern）
- 享元模式（Flyweight Pattern）

  ③行为型模式（ Behavioral Patterns ）：

- 访问者模式（Visitor Pattern）
- 模板模式（Template Pattern）
- 空对象模式（Null Object Pattern）
- 状态模式（State Pattern）
- 观察者模式（Observer Pattern）
- 备忘录模式（Memento Pattern）
- 中介者模式（Mediator Pattern）
- 迭代器模式（Iterator Pattern）
- 解释器模式（Interpreter Pattern）
- 命令模式（Command Pattern）
- 责任链模式（Chain of Responsibility Pattern）

89.简单工厂和抽象工厂有什么区别？



## 附加题

#### 1.使用泛型的好处？

1. 提高代码的安全性，安全性指的是类型安全，类型错误就可以在编译时被捕获了，而不是在运行时当作ClassCastException展示出来。
2. 消除强制类型转换，没有泛型就是object，会有大量的类型转换，比如对josn封装code和msg